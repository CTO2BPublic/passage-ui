##@SectionDefault: Main
replicaCount: 1

image:
  repository: ghcr.io/cto2bpublic/passage-ui
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion.
  tag: latest

imagePullSecrets: []
##@Section: Naming
nameOverride: passage-ui
fullnameOverride: passage-ui

##@Section: Dependency
dependency:
  {}
  # iam:
  #   buckets: "true"
  #   roles:
  #     - role/super
  #     - role/blah
  # onepassword:
  #   secrets:
  #     k8s-secret-as-list1:
  #       - secretKey: spring.datasource.username
  #         remoteRef:
  #           key: db-credentials
  #           property: username
  #       - secretKey: spring.datasource.password
  #         remoteRef:
  #           key: db-credentials
  #           property: password
  #     k8s-secret-as-list2:
  #       - secretKey: spring.datasource.username
  #         remoteRef:
  #           key: db-credentials
  #           property: username
  #     ##  OR
  #     k8s-secret-as-dict1:
  #       spring.datasource.username: db-credentials/username
  #       spring.datasource.password: db-credentials/password
  #     k8s-secret-as-dict2:
  #       spring.datasource.username: db-credentials/username
  #       spring.datasource.password: db-credentials/password

  # db:
  #   type: rds-mysql
  #   keys:
  #     - secretKey: username
  #       envKey: MYSQL_USERNAME
  #       ### namespace, user and instance parameters are optional and can be used to refer to dbs in other dbs
  #       namespace: overridens
  #       user: overrideuser
  #       intance: overrideinstance
  #       ###
  #     - secretKey: password
  #       envKey: MYSQL_PASSWORD
  #     - secretKey: hostname
  #       envKey: HOSTNAME

  # ssm:
  #   # secretName - for user to provide specific secret  name, will be generated automatically otherwise
  #   secretName: nameOfSecretCreated
  #   followKeysFormat: false
  #   # below values can be updated per ssm secret
  #   instance: overridei
  #   namespace: overridens
  #   name: secrets
  #   sOverride: secretsmanager
  #   json: "false"
  #   keys:
  #     - SUPER
  #     - BLAH
  #     - ssmKeys:
  #         - extraSUPER
  #         - extraBLAH
  #       namespace: "extran"
  #       instance: "extrai"
  #       name: "exttarna"
  #       sOverride: secretsmanager
  #       json: "false"
  #     - ssmKeys:
  #         - extraTRUESUPER
  #         - extraTRUEBLAH
  #       namespace: "extran"
  #       instance: "extrai"
  #       name: "exttarna"
  #       sOverride: secretsmanager
  #       json: "true"

##@Section: Advanced
command:
  enabled: false
  disableprobes: false
  command: ["sh", "-c", "tail -f /dev/null"]

updateStrategy:
  {}
  # type: RollingUpdate
  # rollingUpdate:
  #   maxUnavailable: 0%
  #   maxSurge: 50%
customProbes:
  enabled: false
  livenessCommand:
    [
      "/bin/sh",
      "-c",
      "curl http://localhost:8080/health -f --silent --output /dev/null",
    ]
  redinessCommand:
    [
      "/bin/sh",
      "-c",
      "[[ -f /tmp/terminating ]] && exit 1 || curl http://localhost:8080/health -f --silent --output /dev/null || exit 1",
    ]
  readinessProbe:
    initialDelaySeconds: 20
    periodSeconds: 10
    timeoutSeconds: 1
    failureThreshold: 2
    successThreshold: 1
  livenessProbe:
    periodSeconds: 10
    timeoutSeconds: 1
    failureThreshold: 3
    successThreshold: 1
  startupProbe:
    failureThreshold: 10
    initialDelaySeconds: 20
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 1
livenessProbe:
  httpGet:
    path: /
    port: http
readinessProbe:
  httpGet:
    path: /
    port: http
startupProbe:
  httpGet:
    path: /
    port: http
  failureThreshold: 30
  periodSeconds: 10
terminationGracePeriodSeconds: 30
preStop:
  enabled: false
  command: ["sh", "-c", "touch /tmp/terminating && sleep 25"]
features:
  startupProbe: false

grpchosts:
  {}
  # - host: grpc.internal.cto2b.eu
  #   port: 8080
  #   dnsResolver: cto2b-dns

migration:
  {}
  # enabled: false
  # command: ["sh", "-c", "python manage.py migrate"]
  # imageUsePrimary: true
  # image: alpine:latest

initContainers:
  {}
  # containerName:
  #   ## Spec for init container
  #   image: alpine:latest
  #   command: sh

podAnnotations: {}

podSecurityContext:
  {}
  # fsGroup: 2000

securityContext:
  {}
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
  # runAsUser: 1000

nodeSelector: {}

tolerations: []

affinity: {}

kafka:
  certificate:
    requested: false

teleport:
  expose: true

## Volume claim templates make provision type STS instead of Deployment
volumeClaimTemplates:
  {}
  # persistentVolumeClaimRetentionPolicy:
  #   whenDeleted: Retain
  #   whenScaled: Delete
  # name: data
  # mountPath: /data
  # accessModes: [ "ReadWriteOnce" ]
  # storageClassName: "standard"
  # storage: 1Gi

##@Section: Environment
app:
  envValues:
    {}
    # - name: APP_ENV
    #   value: prod
    # - name: DATABASE_HOSTNAME
    #   value: psql-main-any

  envSecrets:
    {}
    # - name: DATABASE_USER
    #   secret: psql-main-app
    #   key: username
    # - name: DATABASE_PASSWORD
    #   secret: psql-main-app
    #   key: password

  envConfigMaps:
    {}
    # - name: DATABASE_HOST
    #   configMap: psql-main-app
    #   key: hostname

  volumes:
    {}
    # emptyDir:
    #   shared:
    #     mountPath: /shared
    #     subPath: shared
    # secrets:
    #   app-credentials:
    #     mountPath: /app/credentials
    #     subPath: shared
    # configMaps:
    #   app-config:
    #     mountPath: /app/config
    #     subPath: shared
    #     data:
    #       key1: value1
    #       key2: value2

##@Section: Service
# Specify port if needed - ussually its 80 http
service:
  type: ClusterIP
  name: http
  port: 80
  # You can override container targetPort if needed
  # targetPort: http
  # or You can add more ports if needed
  # extraPorts:
  #   - port: 8080
  #     targetPort: 8080
  #     protocol: TCP
  #     name: web
  annotations: {}

loadBalancer:
  enabled: false
  annotations: {}
  ports: []
  #   - port: 8080
  #     targetPort: 8080
  #     protocol: TCP
  #     name: web

ports:
  - name: http
    containerPort: 80
    protocol: TCP

##@Section: Ingress
ingress:
  enabled: true
  annotations:
    # This section should be left as is
    cert-manager.io/cluster-issuer: cto2b-dns
    kubernetes.io/ingress.class: traefik
    traefik.ingress.kubernetes.io/router.entrypoints: websecure
    traefik.ingress.kubernetes.io/router.tls: "true"
  hosts:
    # change hostname
    - host: <<._metadata.instance>>.passage-dev.<<.dns.common_name>>
      paths:
        - path: /
          pathType: ImplementationSpecific
  tls:
    - hosts:
        # Change hostname
        - "*.passage-dev.<<.dns.common_name>>"
      secretName: generic-app-secret-<<._metadata.instance>>

  tlsOptions:
    {}
    # minVersion: VersionTLS13
    # clientAuth:
    #   clientAuthType: RequireAndVerifyClientCert
    #   secretNames:
    #     - my-secret

  middlewares: {}
  # middlewares:
  #   ipWhiteList:
  #     sourceRange:
  #       - 127.0.0.1/32
  #       - 192.168.1.7

##@Section: Resources
resources:
  limits:
    cpu: 200m
    memory: 256Mi
  requests:
    cpu: 100m
    memory: 128Mi

##@Section: ServiceAccount
# This sections should not be touched =)
serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

##@Section: Autoscaling
autoscaling:
  hpa:
    enabled: false
    minReplicas: 1
    maxReplicas: 5
    metrics:
      targetCPUUtilization: 80
      #targetMemoryUtilization: 80
  vpa:
    enabled: false

## PodDisruptionBudget ensure specific number of pods are available in case of disruption
podDisruptionBudget:
  enabled: false
  # minAvailable: 1
  # maxUnavailable: 0

metadata: {}
